- 源码优化
  1. 更好的管理和维护代码的方式monorepo
  2. 2.0采用flow 3.0采用TypeScript
    TypeScript提供了更好的类型检查，能支持复杂的类型推导，利于维护

- 性能优化
  1. 源码体积的优化
    - 移除一些冷门的feature
    - 引入了tree-shaking技术
      没有引入的组件，他们的代码就不会打包
      间接减少了项目引入的Vue.js的包体积
  2. 数据劫持优化
    vue的数据响应需要依赖数据劫持来完成，渲染DOM的时候访问了数据，通过访问劫持，就能吃到数据对应的DOM是什么
    - 使用了proxy API做数据劫持 能劫持整个对象。
      - 使用definedPropty劫持时需要传入监测的对象的某个属性，这样就需要definedPropty递归遍历整个对象来达到拦截数据的目的，导致了很大的性能开销。
      - 注意：Proxy API并不能监听到内部深层次的对象变化，于是便在 getter 中去递归响应式
      好处：只有真正访问到的内部对象才会变成响应式，不是无脑的递归，提升了代码性能
    - 使用了 watch 数据结构
  3. 编译优化
    - 对patch过程进行优化
    diff算法，只作用绑定了动态节点的标签，不需要在去遍历这个模板
      - 通过编译阶段对静态模板的分析，编译生成了block tree
      - block tree一个模板基于动态节点指令切割的嵌套区块，每一个区块都有一个Array来追踪自身包含的动态节点
      - 这样将 vnode 更新性能变为与动态内容的数量相关
    - Slot的编译优化
    - 事件侦听函数的缓存优化
    - 运行时重写了diff算法

- 语法API优化：引入Composition API
  1. 2.0 采用 Options API，即编写组件 就是 编写一个 包含了描述组件选项的对象
  通过methods,computed,data,props分类
  需要不断的去切换、寻找逻辑关注点
  
  Composition API 将逻辑关注点相关的代码全都放在一个函数里，这样就不需要正在文件中不断切换找寻
  2. 优化逻辑复用
    2.0 汇入大量mixin时 
      - 可能导致定义相同的变量，导致命名冲突
      - 模板中使用其他地方汇入的变量，就很难发现该变量的出处
    3.0 解决了这两个问题 将函数约定为hook函数
  3. 有更好的类型支持
  4. 都是函数，调用即可，不像Options API所有东西都需使用this访问
  5. Composition API对 tree-shaking友好，代码也容易压缩

- 大规模启用RFC 使每个版本改动可控
  上线使用都需要通过讨论并确认
  阅读RFC，可以了解每一个feature采用或被废弃掉的前因后果

