
** 有些知识是早期写的,不太准确或者片面,以下仅供参考.很多东西只写了标题没写答案**

# 自我介绍 
  <!-- 面试官,您好,我叫黄力豪,来自江西抚州,是东华理工大学软件工程21届毕业生,从学习前端到现在20来个月的时间,自我感觉js/ts基础知识较为扎实,主要使用框架是vue2/vue3并用其原创了几个小项目,对vue原理也有一点小的理解.对webpack,HTTP,浏览器也有一点理解.平时喜欢看一些技术博客关注最新前端发展动向以及积累自己的技术,也喜欢看一些技术书籍如深入浅出vue.js,深入浅出es6,高级程序设计,css世界等,为人自信积极乐观向上.有较丰富的实习经验,曾在逻辑思维和滴滴出行负责一些TOB端业务

  我对于未来三年的规划主要是深入挖掘NodeJS,同时紧跟时代,学习最新的技术.

  以上就是我的个人简介,希望贵公司能给一个平台让我展现自己. -->

# 为什么离职

# 最快什么时候能入职
  马上

# 在公司干了什么

   在得到app实习写了一个软件，就是可视化编写风控代码，就是操作节目生存风控代码，或者使用风控代码生存界面。也没有什么难度，就是使用大量正则去匹配。当然没有使用ast去分析，那个时候对ast还不了解。

   还有就是维护一个老项目，就是业务程序，没什么难度。但是发现业务代码对TS支持不友好,就是还有很多重复代码,就想着优化就是编写了一款插件啊，主要就是将json数据转化为ts类型，调用swaggerUI地址，解析swaggerUI 里面的请求体和响应体里面的json，然后转化为ts，然后自动生成接口函数，给接口函数自动加上请求体和响应体，还有就是这个插件还集成了一些其他功能，比如自动生产一个基本页面。比如面包雪组建，路由，api调用等

  <!-- 滴滴出行这边实行三个月，前前后后接触了10来个项目吧，还挺忙的，不过大多就是写一些业务代码，
  vue，react，node，mysql都写，难度倒是没什么难度，上班写的代码基本google都能出来。
  完整的项目就写了一个，就是用echarts写了一个大屏项目，放哪儿展示的。 -->


  滴滴实习  着重讲模板平台 ,项目架构.

# 项目亮点

# 你有什么想问的


# let var 区别

1. let将变量存在词法环境,var将变量存在环境变量,查找一个变量先查词法环境(let 块级作用域的原理)

2. 解析阶段,let会将变量加入暂时性死区,访问暂时性死区的变量报错(let 没有变量提升的原因,其实有,只是会报错)


# 闭包

1. 作用域链

2. v8预解析

3. GC对闭包的处理

# 跨域

  - 同源策略 

  - 为什么需要同源策略
    1. 防止第三方脚本操作本页面dom
    2. 防止第三方脚本读取数据
    3. 不能将数据发送给不同源的页面

  - 但是我们有时候为了便利又要上面三条,怎么解决
    1. 浏览器可以直接使用script引入第三方js,但是这样会带来xss攻击,(被对方通过各种方式注入),所以加了CSP,内容安全策略,指那些脚本可以被执行
    2. cors跨资源共享请求
    3. 两个不同源的dom是不能操作的,这时候又引入postMessage 进行跨文档消息机制

  - 九大跨域方法
    说主要的,不要逼逼赖赖

  - cors 请求流程

    1. 判断是否存在origin头，如果没有不是一个合法的跨域

    2. 判断请求是否是options请求

    3. 是options请求判断 method头部是否存在

    4. 发送 options请求

    5. 判断method字段是否有效

    6. 是否存在header字段

    7. 服务端设置method,header,max-age,origin字段

    8. 是否携带cookie ,服务端设置credentials

    9. response 没有响应体

  


# 请求头
  - DATE , proxy ,Connection , content 一族 accept 一族, 缓存一族,cook一族,

# 状态码

# 模块化

 - 一个函数就是一个模块，造成全局污染
 - 名命空间 对象属性会被修改
 - commonJS 一个文件就是模块，通过exports / export default 导出，require 导入，值会被缓存，而且是同步的，同时是浅拷贝

  commonJS 流程简单说一下

 - amd

 - cmd


 - import

  1 首先建立依赖树，依赖树的建立是通过import语句来确认的。 还要给一个入口文件，用来确认依赖树的入口

  2 浏览器理解不了这些文件，所以要把这些文件先转化成模块记录的一种数据结构，这样浏览器才能理解

  3 然后将模块纪录 转化为模块实例 ，模块实例包含code和状态两种东西，code 就是一些指令，state 是变量在时间点的值

  模块实例的产生步骤

  构造 - 实例 - 求值



  1 构造  1.1首先通过入口文件找到要下载的文件，然后文件中有import语句，找到import的说明符去找下一个文件

  这个时候还没有进行求值，所以不能在import语句中使用变量，如果在构造的时候就求值会造成危害，如果某个模块下载太慢导致阻塞则会造成后面使用import语句的模块都被阻塞，而node可以使用变量，是因为node的构造，实例求值是一起完成的，原因是node读取本地磁盘速度很快。

  但是动态导入又是需要的，所以会给动态导入创建一个新的依赖树。

  一个模块只有一个实例，然后将实例缓存起来，这样无论多少个模块引入同一个模块，都只会引入一次

  
  1.2  解析

  首先将文件转化为模块记录，然后将模块记录存在模块map中，这意味着无论何时请求都可以从map中获取


  在解析之前，要先知道这是不是应该模块，html加type = module即可，node使用mjs后缀文件


  2 实例化  创建一个模块记录环境，这个模块记录环境保存着import和export之间的依赖关系，同时采用深度后序遍历算法，直到找到最底层，就是不依赖其他任何模块的模块，并且设置好他们的导出

  当一个模块设置好所有的导出就会返回上一级设置所有的导入，这样的好处就是保证所有的模块都可以找到对应的导出且指向同一个地址，这样的好处就是当值修改时，导入的模块的值也会被时时修改，而commonJS 时对值的拷贝，并不能体现这一点。


  3 求值 
  通过执行js代码往内存中填值


# cookie session token 

  - 存在原因, HTTP 是无状态的

  - cookie存在客服端,有大小以及数量限制,而且容易遭到xss以及csrf攻击,每次请求都会自动带上cookie

  - session 存在服务端,比cookie安全,但是存储过多会给服务端造成压力

  - token 由服务端生成进行加密传输给客服端,客服端再通过请求头发送给服务端,服务端通过解密那到用户信息

  

# 缓存
  
  - 强缓存  状态码 200
    
    expriess  对比本地时间
    
    catchControl 相对时间


  - 协商缓存  状态码 304

    Last-Modified 表示本地文件最后修改日期

    ETag  文件指纹


  - 流程


# 安全
   ##  xss 
   - 危害: 获取cookie,执行恶意代码,截流等
   - 注入方式: 往页面注入脚本(mysql注入,url带script脚本(基本被现代框架屏蔽了),网络截持等)
   - 防御: 正则匹配,csp,httpOnly

   ## csrf
      
   ## mysql注入

   ## 中间人攻击

# http系列

- HTTP 三次握手

  第一次握手：首先客服端发起建立连接请求 ，状态变为 syn-send状态 syn =1，发送一个随机序列号，seq =x

  第二次握手：服务端接受到客服端发过来到请求， syn =1 ，确认标示ACK =1 。确认号ack = x+1，并发送自己到随机序列号seq = y 状态变为 syn-=REcv状态

  第三次握手： 客服端接受到syn报文，确认标示 ACK =1，seq =x+1 ack=y+1 然后状态变为 establish 状态
  服务端接受到ack 报文后，状态也变为establish 状态 。此时建立连接成功。

- 为什么需要三次握手

  客服端发送一个请求，因为网络原因发送失败，这个时候采用超时重传机制，再次发送一个请求，第二个请求顺利到达。
  数据传输完毕，关闭连接。
  恰好，这个时候第一个请求到了。服务端以为客服端重新发了一个网络请求，但是客服端这时已经关闭，服务队会一直等待客服端的响应。导致浪费资源

- HTTP 四次挥手
  第一次：由客服端发起断开连接请求，将状态变为 fin_wait1 状态。发送fin =1 ，随机序列号 seq=x

  第二次挥手 服务端收到 客服端的fin后，产生seq = y，ack =x+1，ACK =1 自身状态变为 close_wait
  客服端收到ACK后，状态变为fin——wait2

  第三次挥手 服务端发完最后数据也想断开 发送 fin=1，ack=y+1，seq=z，ACK=1， 状态变为last——ACK

  第四次挥手 客服端收到服务端的fin后，发送ACK=1，ack=z+1，seq =x+1 ，客服端进入timeWAIT状态

  服务端收到客服端的ACK后，进入close状态，等2个最长报文段寿命后，客服端也进入close状态

- 为什么需要四次挥手
  因为TCP是半关闭的，接受和发送能力不是同时关闭的。一次只关闭一种状态。
  客服端和服务队 2*2 =4 

- HTTP 0.9
  只能简单接受html文件

- HTTP1.0
  被浏览器倒逼,加上了请求头和响应头,为了减少传输性能,还加上压缩,状态码,缓存,代理等都是http1.0引入的.
- HTTP1.1
  HTTP 每请求一个文件都要都要进行三次握手,四次挥手,特别耗性能,HTTP增加了持久连接的方法,只要服务器和客服端不断开连接,TCP连接就不会断开,可以在一个TCP上发送多个请求,但是如果某个请求被阻塞了,就会导致后面的请求无法到达,这就是队头阻塞.每个域名最多能维持6个TCP连接(谷歌浏览器),如果想超过6个,可以使用CND域名切片,就是二级域名.

  ## HTTP1.1 带来的性能问题(带宽率不高)
  - 多个TCP连接竞争带宽,但是又不能协商那个优先级高,导致重要资源可能下载较慢
  - 每个TCP连接都需要慢启动(主要为了避免网络拥塞),就和飞机起飞一样
  - 队头阻塞

# https系列


  - 证书包含哪些东西

    - 公钥,私钥,证书颁布机构,证书过期时间等

  - 为什么需要证书
    
    防止中间人攻击


  - 中间人攻击
     客服端与服务端加一个中间服务器,这台服务器同时充当客服端和服务端分别于原客服端服务端通信

  - HTTPS流程
    

# http2系列
  - 多路复用
    TCP 慢启动无法避免,那么HTTP2只建立一条TCP连接,那么慢启动的次数就减少了,通过二进制帧(多个帧并行发送)在一条线上发送数据,给每个帧标明id,到时候重组相同帧的数据就行,同时也可以设置优先级高的请求,如果有优先级高的请求就会暂停其他请求

  - 服务端推送

  - 首部压缩

  ##  HTTP2缺陷
  
  - 当HTTP2存在丢包情况下,因为HTTP2所有数据都是建立在一个TCP连接上,如果出现丢包则会导致所有请求造成阻塞,所以丢包率过大HTTP2可能不如1.1,TCP握手也需要一定的时间,而因为一些TCP协议,很难去优化TCP这些问题.
   

# HTTP3 系列
  - TCP协议有些底层上的协议,所以我们绕过TCP协议,使用UDP协议,但是UDP协议又不保证可靠,使用QUIC 协议对UDP协议进行包装.可以简单看成HTTP2和UDP的结合.但是HTTP3也存在一些问题,例如浏览器的支持,UDP的优化率不及TCP等

# 浏览器

  - 事件循环  

    - 流程

    - 为什么需要微任务,mutationobserve诞生

    - settimeout 特点  延迟队列

    - v8 对事件循环的优化

  - url输入到页面渲染

    - chrome 多进程架构为例

    - query/url查询

    - 查询是否存在强缓存

    - DNS 查询 解析IP

      - 先查本地 hosts 文件
      
      - 浏览器 -> 本地DNS 服务器 

        - 根DNS 服务器

        - 域 服务器

        - 域名解析服务器

    - TCP 三次握手

    - IP 在网络层只能找到主机,通过TCP/UDP在传输层找到端口确定将数据发送给哪个应用程序

    - 判断是否有协商缓存,重定向这些

    - 通过content-type字段判断是否是html文件

    - 将字节流转化为字符流

    - 浏览器不能理解html , 通过ast(有限状态机)将html 转化为Token 流 再转化为dom树

    - css 转化为cssDom树

    - 可能会碰到script 标签,查询cssDOM树是否构建完毕,阻塞dom渲染,但是浏览器会通过优化手段把一些文件先进行下载

    - 将cssDOM树 DOM 树合并为 layout 树 

    - 由于屏幕是二维的,其实我们的dom视图理论是三维的,可以理解z轴接近0,如纸般覆盖. 这时候就要将layout树转化为layer树,进行分层,比如动画,滚动条,zindex 主要防止回流重绘,为每个图层生成绘制列表(绘制优先级)
    
    - 将图层转化为图块(256*256 / 512*512),如果页面很长,一下渲染所有的比较耗性能,根据离屏幕的区域优先绘制哪些图块,将图块绘制成位图

    - 光栅化 图块转位图

    - 合成位图 放在GPu 后缓存区

    - 交换前后缓冲区,显示器读前缓冲器

    - 断开TCP 四次挥手


    ___________ 最好加上进程和线程去说

  - js 执行过程

    - 编译阶段
      1. 执行上下文：一段代码的运行环境


        - 变量环境
          当声明一个变量时,(var)加入到环境变量,普通变量赋值undefined,函数放入堆内存中,再用指针指向,

        - 词法环境

          let,const 加入到词法环境.

      2. 可执行代码
        - 其他代码转化为字节码
 
    - 执行过程

      将可执行代码一行一行执行,去环境变量中找.当执行到函数时,去全局环境变量中找到函数,然后进入函数,创建函数执行上下文,函数中又可以调用函数,通过栈结构来管理,就叫做调用栈,函数执行完会销毁函数执行上下文,出栈并将值赋予给变量.
  
# 基础api源码手写

  - apply deepClone 防抖节流 promise全家桶

# vue3 原理细说

# vue2 流程细说

# vue2 和vue3 区别

设计上

一：vue3使用components Api 取代 class 类的形式，这主要有2个好处

1:ts对this支持不是特别友好，vue使用class 形式，对一些插件例如vuex，vuerouter 这种都没有类型。

2:通过import引入对比vue2对象形式，import可以很好的做到treeShank ，而对象不可能做到。

二：使用provide /inject 注册插件取代以前使用mixins混入beforeCreate生命周期形式。

使用混入有三个缺点：
1:缺少this上的类型
2：某些组建根本没有使用vuex vue-router 也会进行混入
3:在vue2中，mixins有一些缺陷。稍后再说。

三：相比与以前vue2就是一个整体，而vue3更像是一个积木，对某些你不要的功能可以不拼接，单独的积木也可以单独使用。也可以重新设计自己的积木进行使用，例如重新设计自己的createApp，定义dom渲染的形式。

还可以将reactive单独在ts文件中使用,使用reactive对数据源进行包装，然后利用es6 import 对值引用的特性，做数据共享取代vuex，就是两个文件同时引用一个数据源

同时可以将一些代码封装到函数中，要使用的时候，页面直接引用就行，通过这种方式做到js共享，取代以前的mixins。mixins有一些缺陷，就是不容易追踪数据，逻辑混乱等，例如将，data，method 进行参数合并，生命周期加入队列然后遍历执行，你完全不知道数据来源和生命周期来自那个mixins

四：在vue3中可以更好的使用jsx/tsx，tsx相比与vue模板有什么好处

1：首先在vue的tsx中也可以使用一些指令，例如v-model.这是react都不具备的
2:tsx相当与在写ts，好处就是在dom中也可以使用ts类型检查，而template模板都是字符串，然后通过正则翻译。在template中不能使用ts。
3:tsx缺点：tsx写样式相对与vue有很大的差距，除此之外，性能也有一些差距
template模板在编译阶段先转化成ast树，然后对ast树遍历找出静态节点并将取提升到render函数之外（vue2进行标记）这样以后在数据改变是，和静态节点就没有半毛钱关系。
而tsx 完全就是利用babel ast词法分析对代码进行转译，而ts有很强的执行上下文，很难对静态节点进行优化，因为可能改变上下文环境。

五：可以使用vite打包工具

vite 本质上就是一个koa服务器。

vite相比与webpack

先说缺点，生态不足，碰到问题很难解决，另外教程不足。

优点:利用es6 import 天生做到按需加载，打包速度是webpack的几倍-几十倍

原理：简单说一下.主要自己也理解不深

主要利用es6 import 而，import只对 / ， ./ ,../ 前缀的生效，

所以我们要先分析那些模块没有这些前缀，就是一些第三方包，然后给这些模块加一个前缀，例如/@node—modules.

然后加了前缀就要找到真正的包，所以要进行map进行一下映射，请求真正的包。

很久没看，忘记了。。。。。


vite 热更新简介， 利用node 监听文件变化模块，同时建立websocket链接，文件一变化，就给客服端发送一个请求，客服端调用reload进行更新



## 功能上

基本兼容vue2 ， 对某些api进行破坏了，例如$on,beforeCreate 

新加css 属性响应式，dom传送门，watch改为监听数组，就是可以同时监听多个值，
watchEffect 等等 ，这些都没有什么说的，基本功能。

使用reactive 代替以前的data，主要就是可以直接对数组进行响应式，同时可以定义多个数据源。

直接声明一个变量然后return 就可以在模板中使用，以前vue2定义不响应的数据只能使用Object.freeze()对对象进行冻结。


others。。。。乱七八糟一堆没必要说




## 原理上
其实前面已经或多或少说了一些原理，这里简单说一下几个核心api原理

响应式原理对比：

相比与以前使用Object.defineProperty 拦截数组原型链，重写数组方法那些破烂，
vue3使用proxy可以直接使数组相应，只要注意修改数组长度会触发两次，因为length属性也改变了。

然后就是proxy代理的是对象，Object.defineProperty代理的是属性，这直接少了一次for循环，而且加上各种递归，少了很多时间复杂度
另外就是vue2在一开始就对数据进行深度递归，而vue3是在get中进行懒递归，但只有读这个数据的时候才会递归。

收集依赖和以前差不多一个思路，收集的时候区分一下computed和reactive数据就好，
computed具体忘记了，大概和就是加了一个dirty属性判断是否可以缓存，然后get了一下value属性，同时和属性进行绑定了，因为属性改变，computed也要改变。

set触发依赖区分一下是改值还是新加就好，嗯，就是利用发布订阅模式。然后以前是使用数组，对象现在改成set，map而已


然后就是dom-diff

虚拟dom已经没有什么好优化的，优化在算法上

这玩意就是在render函数中调用一下patch，render函数又在effect函数中调用，
effect函数初始调用一次，值改变再调用一次，正好符合render调用机制

path这玩意就是先path自己的，再patch孩子进行递归，
比如patchProps 递归比较props就行，使用map数据结构保存一份index=>key的映射，防止元素移动位置比对错误

然后vue3的patch在算法上做了一些优化，什么头头比较，尾尾比较这些，具体算法早忘记了啊。

至于模板编译我觉得就是看自己正则水平怎么样啊，这个我没去看，个人感觉写一个简单的模板编译应该没有问题，因为有过一些正则的研究。

# 简介expriess 原理
  expriess 主要 用来处理路由以及中间件,主要方法就是app.get,app.post等,这些方法都是被遍历出来的,还有一个就是app.use方法. expriess 有一个router类,这上面有一个栈,无论是路由还是中间键都会进入这个栈,路由和栈都是一个layer,其别在于路由有一个route属性,同时无论是中间键还是路由这个时候只处理了path,而没有处理method,当然中间件也没有method. 那么method怎么处理呢 ? 前面说了路由的话还有一个route属性,route同样有一个栈,这个栈同样收集一个layer,区别在于这个layer有method属性无path属性,同时真正的回调在这里,可以简单看成一个二维数组.

  expriess处理路由和中间件也是通过迭代的方式,简单来说,就是通过递归的方式处理两层for循环,这样才能保证执行顺序.

# 简介koa原理

  koa总共就4个文件夹，request，response，context，appliaction

  其中 request，response，对req,res包装,context 就是使用get，set代理一下，
  比如代理ctx 然后ctx.url 拿到ctx.request.url,ctx.body 拿到ctx.reqsponse.body,取值同理


  application 首先包装一下http创建一个服务器,然后就是通过Object.create方法,这样就可以拿到父对象的属性然后修改还不会影响到父亲,就是一个简单的原型操作,再然后进行交叉赋值,主要就是为了方便拿值然后将request,response 聚合在context上

  最重要的就是中间件,中间件的作用.

  1:统一拦截

  2:扩展属性

  3.分割逻辑,基于中间键做插件

  所有use方法都会被promise包装,内部next必须加await 或者return


  中间键原理 
  发布订阅加迭代
  很简单,首先调用use函数入栈,然后执行的时候,用promise包装一下,调用next方法的时候执行下一个.使用迭代递归的方式保证执行顺序

# 简要对比koa和express

 1. expriess 路由自身集成
 2. expriess 使用callback 回调 ,koa 使用async promise
 3. koa 将request,response 集成在ctx上
 4. 中间件原理不同

# webpack原理


1.检查配置是否合法

2.合并参数

3.声明complier对象

简单说一下complier对象,主要就是在hooks对象中构建一些钩子,这些钩子都是同步或者异步的发布订阅,当编写一个插件的时候,订阅一下这些钩子.complier还有一些方法,大多是在构建过程发布或者订阅一些钩子

4.给complier加上读写功能

5.遍历执行plugin进行挂载.

6.注册一些初始化或者触发一些初始化的事件,最关键的是注册make事件,make事件主要是用来添加入口的.

7.执行complier的run方法,基本大部分方法都会发布和订阅一些钩子以后就不说了,主要是去执行complier方法,complier对象主要是去声明complation对象和发布make事件

8.complation 的主要功能是来构建模块和代码块,和complier一样也有一些乱七八糟的钩子,在触发make的回调后开始正式执行complation的方法,主要就是利用complier的读功能拿到源代码,将其转化为ast,遍历ast找到其中的require和import, 对其引用的模块加一个模块id,模块id就是经过转化后相对根目录的相对路径,在这里顺便确认一下入口目录,然后对某些ast进行修改,然后递归执行.这里会得到一个包含入口文件和依赖文件的chunk.
import则要进行拆包，生成一个blocks数组用来记录引用那些异步代码块，然后对其遍历使用complation添加新的模块


9.在make执行完毕后出发回调,执行emit钩子,这个时候要进行文件进行写操作,将chunk转化为代码,是最后修改文件的时候



# webpack 热更新原理

# webpack 基础

模块打包机,本身只能打包js.通过loader处理可以打包其他模块

webpack 配置只是一个对象参数.

这个对象有以下属性

entry: 入口目录,可以配置一个或者多个,

output: 出口目录

plugin : 插件,监听webpack的声明周期,然后做一些额外的操作,

本质就是一个class,然后在一些同步或者异步hooks订阅一些事件,当webpack执行到一定时机去发布这些事件

chunk:代码块,用于代码分割和合并

Loader:翻译官,配置在module的test当中,本质就是一个函数,函数入参是源代码,返回值是经过翻译后的代码,webpack内部提供了util工具包去操作它,loader遵循单一原则,一个loader只做一件事.loader有字符串,对象数组三种形式,遵守从后到前,从右到左执行顺序,可以进行配置顺序

context: 设置项目根目录,默认当前目录

devserver:配置开发服务器  

mode:模式

devtool: 代码调试

reslove: 配置别名,后缀名

## 二:优化

构建优化先分析问题.webpack有插件可以分析

1.purgecss 去除未使用css

2.压缩代码,减小代码体积

2.dll 生成动态库,wp5貌似可以不配置,wp5可以使用缓存

3.多进程处理

4.cdn 

5.tree shanking 

6.代码分割:配置多入口和动态import 提取公共代码 

7.HMR








# npm i 流程

 - 检查配置是否合法
 - 检查是否有lock文件
 - 无lock 获取远程包信息 ,将npm 包结构打平. 
 - 查看是否有缓存
 - 无缓存直接下载
 - 检验包的完整性

 - 完整添加到缓存

 - 解压到对应的node_modules

 - 下载lock

# GC

1. 堆栈的垃圾回收

2. 主副垃圾回收器

3. v8 对垃圾回收的优化


# 设计模式

  说几个就行,说一下那些库用了那些模式,结合实际.

 - 工厂模式  

 - 原型模式    Koa

 - 装饰模式  Weboack plugin

 - 发布订阅 webpack Tabable ,vue依赖收集和触发,Koa中间件.事件机制

 - 代理模式 koa context,vue响应式数据

 - 单例模式  

 - 外观模式 各类库 Jquery

 - 策略模式 状态码


# AST 

# 堆栈

# 递归

# 二叉树

# 链表
