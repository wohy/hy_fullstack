11. es6数组常用方法
  https://es6.ruanyifeng.com/#docs/array

12. JS 异步解决方案的发展历程以及优缺点
  由于JS是单线程的语言，如果只有同步代码的话，运行就可能会造成阻塞，因为当前执行一段同步代码，后面的代码执行就会先被阻塞，而引入异步代码后，就不需要等待代码执行的返回结果，而是可以直接执行异步任务后面的代码，这样就可避免阻塞
  - 异步编程的发展历程：
    1. 回调函数：最早，通过一些典型的事件回调，或者setTimeout、setInterval实现
    问题：当回调的层级嵌套过多时，会带来地狱回调问题
    2. 为了解决地狱回调，提出了Promise
      优点：可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数
      缺点：可能需要些很多then的方法链，没有从根本上解决地狱回调问题，依旧很难维护
      之后引入了.all()方法就优化了些
    3. ES6引入Generator异步编程解决方案
    4. ES7中提出的方法async/await，async是Generator的语法糖，返回的是一个promise对象
      优点：代码更加的清楚

13. Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？

14. 如何实现一个new
  使用Object.create()，将原构造函数的原型深拷贝下来
  再通过apply，将参数传入，并绑定fn的this到obj中，并执行，若返回的是一个对象类型则返回，若不是，则直接返回拷贝下来的原型
  ```
    function _new(fn, ...arg) {
      const obj = Object.create(fn.prototype);
      const ret = fn.apply(obj, arg);
      return ret instanceof Object ? ret : obj;
  }
  ```

15. 简单讲解一下http2的多路复用
  1. 数据以二进制格式传输的
  2. 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。
  多路复用代替了HTTP1.x的序列和阻塞机制，同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。
  避免了队头阻塞问题，极大的提高传输性能
  3. 单个连接上可以并行交错的请求和响应，之间互不干扰

16. 谈谈你对TCP三次握手和四次挥手的理解
  - 三次握手：
    1. 客户端向服务端发送数据请求
    2. 服务端向客户端发送请求应答
    3. 客户端发送确认连接信号给服务端
  - 四次挥手：
    1. 客户端请求释放连接请求
    2. 服务端接收到释放请求，会告诉应用层要释放TCP连接了，就会发送ACK包，并进入CLOSE_wait状态 (完成后客户端是不能向服务端发送数据了，可TCP连接是双向的，此时服务端还是可以给客户发送数据的)
    3. 服务端向客户端发送没有发送完的数据
    4. 客户端接收到最后一份数据后，向服务端发起确认断开请求，2ms后如果没有得到应答，就自动断开