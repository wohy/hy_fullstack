<script>
  // 量词
  // {1, 2}
  var reg = /ab{2,5}/
  // 内容
  // ab 或者 ba
  var reg1 = /ab|ba/
  var reg2 = /a[123]b/
  // a1b a2b a3b
  var reg2 = /[5-9a-z]/
  // [0-9] 缩写为 \d
  // [0-9 a-z A-z] \w

  console.log(reg.test('bbbbbbbbbb')); //false
  console.log(reg1.test('bbbbbbbbabb')); //true
  console.log(reg1.test('ab'));

  // 颜色正则表示
  // 十六进制 0-9，a-f
  // 颜色 #666 #eee
  // 开头：#
  // 后面接 3 | 6 位的数字或字母组合 
  let colorReg = /#[0-9a-fA-F]{3}|#[0-9a-fA-F]{6}/
  let colorReg1 = /#([0-9a-fA-F]{3}|#[0-9a-fA-F]{6})/    //或用这钟方法表示 ()进行分组

  console.log(colorReg.test('#666'));
  console.log(colorReg1.test('#666'));

  // exec() 正则表达式的核心AP
  console.log(colorReg1.exec('#eeefff')); //可知道从哪位开始匹配的，匹配的字符...

  // 24小时格式
  // let timeReg = /[0-23]:[0-59]/  错误  其中的23 会认为是2或3,59也一样，所以需要分开
  let timeReg1 = /[01][0-9]|[2][0-3]:[0-5][0-9]/
  console.log(timeReg1.test('18:56'));

  // 2020-11-30
  // YYY-MM-DD 年份表达
  // ^....$ 表达式起点到终点必须满足该格式
  let regYear = /^[0-9]{4,}-(0[1-9]|[1][0-2])-(0[1-9]|[12][0-9]|[3][01])$/
  console.log(regYear.test('2020-11-29'));

  // 当在这则后加一个g时，g不属于正则中的,加了g就会有lastIndex属性
  let reg3 = /a/g
  let str = 'aaa'
  console.log(reg3.test(str)); //true
  console.log(reg3.test(str)); //true
  console.log(reg3.test(str)); //true
  // lastIndex属性代表正则每次匹配的最后一个位置
  console.log(reg3.lastIndex); //3
  console.log(reg3.test(str)); //false  从3开始往后匹配，可第三个位置后为空，所就会返回false
  console.log(reg3.test(str)); //true 又会从头开始匹配
  // 为了避免以上的错误
  console.log(/a/g.test(str)); //每次都需拿该正则来匹配


</script>