# 与你不知道的JavaScript上卷类似

# 两种数据类型
当赋值给变量时，解析器必须确定这个值是哪种类型的数据
- 基本类型的值；简单的数据段(Undefined、Null、Boolean、Number、String)
  按值访问的，因为可以操作保存在变量中的实际值
  基本类型的值不能添加属性
- 引用类型的值：是保存在内存中的对象
  按引用访问
  包含引用类型的值的变量实际上包含的并不是对象本身，而是指向该对象的指针
  当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象
- 复制变量值
  - 一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上
    ``` 
    var num1 = 5;
    var num2 = num1
    ```
  复制好后，两个变量可以参与任何操作不会相互影响 (为深拷贝)
  - 当一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。
  不同的是，这个值的副本实际上是一个指针，而指针指向存储在堆中的一个对象。
  则复制好后，两个变量实际上将引用同一个，改变一个另一个也会被影响 (为浅拷贝)
    ```
    var obj1 = new Object()
    var obj2 = obj1;
    obj1.name = 'wn';
    alert(obj.name) //'wn'
    ```
- 参数的传递
  - 传参，即把函数外部的值复制给函数内部的参数，就和把值从一个变量复制给另一个变量一样
  - 所有函数的参数都是按值传递的
  - 原理：
    1. 向参数传递基本类型的值时，值会被复制到一个局部变量(命名参数，arguments对象的一个元素中)
    2. 局部变量的变化反映在函数的外部
      ```
      function addTen(num) {
        num += 10;
        return num;
      }
      var count = 20;
      var result = addTen(count); //count的值20被复制给num
      alert(result)  //30
      alert(count) //20
      ```
    3. 当传入的参数是一个对象时
      ```
      function setName(obj) {
        obj.name = 'wn';
        obj = new Object();
        obj.name = 'hy';
      }
      var person = new Object();
      setName(person);
      alert(person.name); //'wn'
      ```
      可见当传入的是对象时，依然是按值传递的，person 传入时，首先会被设置一个name属性为'wn'，之后将一个新对象赋值给obj属性，将其obj的name设置为'hy'。若为按引用传入，则person会修改为指向name为'hy'的新对象，可下次访问person.name时依然为wn，则说明，即使函数内部修改了参数的值，但原始的应用依然不会改变。因为实际上，函数内部重写的obj时，这个变量引用的只是一个局部变量，当函数执行完毕时，会被销毁
- 检测数据类型
  - typeof：
    - 可检测出：字符串、数值、布尔值、还是undefined (检测基本数据类型的得力助手)
    - 可若为null或对象时，都会返回object
  - instanceof：
    - 检测Object、Array、RegExp类型(检测引用类型)，而所有引用类型都是Object的实例
    - 检测基本类型的值，该操作符会始终返回false
# 执行环境与作用域
- 执行环境(execution context)：定义了变量或函数有权访问的其他数据，决定了他们各自的行为，每个执行环境都有与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，解析器处理数据时在后台会使用它。函数的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，函数执行完之后，栈会将其环境弹出，将控制权交返回给之前的执行环境。而当代码在一个环境中执行时，会创建一个变量对象的作用域链，内层可沿着链访问到外层的环境中的对象，一直延续到全局执行环境；全局执行环境的变量对象始终是作用域链的最后一个对象
- 全局执行环境：web浏览器中为window对象。全局执行环境直到应用程序退出才会被销毁
- 延长作用域链
  - try-catch语句的catch块：创建一个新的变量对象，其中包括的是被抛出的错误对象的声明
  - with语句：将指定对象添加到作用域链中，如，``` with(person) {var name = pname} ```若with所在执行环境的作用域链上找不到pname，则此处的pname访问的即是person对象中的pname，且创建出来的name也会都该执行环境的变量对象中
  两个语句都会在作用域链的前端添加一个变量对象
