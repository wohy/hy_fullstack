# 垃圾回收
- 手动回收
  例如：C、C++

- 自动回收
  例如：JavaScript、Java、python
  垃圾回收器

# JavaScript栈调用栈的垃圾回收
  - ESP 指针，代码在执行哪个，就指向那个执行上下文
  - JavaScript引擎通过向下移动ESP指针来销毁函数保存在栈当中的执行上下文
  - ESP 上一步所指的执行上下文会消失

# JavaScript堆空间的垃圾回收
  保存在的堆空间中被该执行上下文引用的引用数据类型也应跟着该执行上下文一起被回收
  - 代际假说 和 分代收集

  ## 代际假说 和 分代收集
    - 代际假说(人为的一种认知)
      1. 大部分对象在内存中存在的时间很短，简单来说就是很多对象一经分配内存，很快就变得不可访问
      2. 不死的对象会活的更久
    - 分代收集
      V8 会把堆分成 新生代 和 老生代 两个区
        - 新生代：存放生存时间短的对象  通常1~8M的容量 
          被副垃圾回收器回收
        - 老生代：存放时间长的对象  容量很大
          被主垃圾回收器回收

# 垃圾回收器的工作原理
  不论什么类型的垃圾回收器，都有一套共同的执行流程
  1. 标记空间中的  活动对象(还在使用的对象) 和 非活动对象(可以进行垃圾回收的对象)
  2. 回收非活动对象所占据的内存
  3. 内存整理(频繁回收对象后，就会出现大量不连续的空间，称为内存碎片，若下次需要存放一个很大的对象，可可能连续的空间不足，所以内存整理是很有必要的)

  ## 副垃圾回收器
    主要回收新生代区的垃圾回收，通常请况下，大多数小的对象都会被分配到新生代区，回收是频繁
    - scavenge算法：主要用于新生代的垃圾回收，将新生代对半分为两个区域，对象区和空闲区，然后标记对象区的所用对象，将存活的对象复制到空闲区中，复制的过程中还会做好排序，相当做了一次内存整理，最后清空对象区域，在将空闲区与对象区角色翻转
    - 当存活对象过多，新生代空间不足时，js会采用对象晋升策略(经过两次垃圾回收还存活的对象，直接移动到老生区)

  ## 主垃圾回收器
    主要负责老生区的垃圾回收
    老生区中的对象来自于新生区中晋升的对象，和本身就占据空间大的对象
    - 对象占用的空间较大，复制时的效率较低，开销也大，所以不适用 scavenge 算法
    - 采用标记-清除算法
      首先是标记阶段：通过递归遍历对象，遍历到有一个节点是活对象，那这组对象就是活对象，一个活对象都没有，则整个对象都是垃圾数据
      标记是垃圾数据的，将对其进行回收

# 垃圾回收带来的全停顿问题
  ## 产生原因
    因为JavaScript是运行v8的主线程上的，而垃圾回收的算法也是在主线程中
    单线程下，引擎只能做一件事情
    那么就会出现，当需要垃圾回收时，导致js的执行停住，直到垃圾回收机制完成
    这就是全停顿问题

    新生区存放的对象小，存在时间短，所以垃圾的回收所需时间就短些，所以全停顿影响不大
    可老生区的对象大，存在时间长，垃圾的回收所需时间就长，全停顿的影响就大了

  ## 解决
  V8采用增量标记，将标记过程分成一个个标记过程，同时让垃圾回收的标记与js执行操作交替进行，把垃圾回收分成更小的片段，这样避免了明显的卡顿，影响用户体验


# nodeJs 中的内存管理
node 端的内存泄漏问题：
  对于持续运行的服务器进程 Node 服务器端程序，必须及时释放不再用到的内存。否则内存占用会越来越大，轻则影响系统性能，重则导致系统崩溃