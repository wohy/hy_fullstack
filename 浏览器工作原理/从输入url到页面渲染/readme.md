1. 浏览器对url进行解析DNS
找到该url的IP地址
对url进行查询，在当前本地服务器，上查询有没有该页面的信息，没有则依次一直向高层服务器查询

2. 查询到了url相关信息之后
与url信息所在IP地址的服务器进行通信：3次握手和四次挥手
- 客户端向远程的那个服务器发送数据请求报文
- 远程服务器接收到请求，向客户端发送应答
- 客户端接收到应答，确认可以接收信息，之后将确认连接信息发送给远程服务器
3次握手完成
3. 两个服务器就开始了TCP通信
4. 通信完毕，需要断开连接，则进行4次挥手
- 客户端向服务端发送连接释放请求
- 服务端接收到释放请求，会告诉应用层要释放TCP连接了，就会发送ACK包，并进入CLOSE_wait状态 (完成后客户端是不能向服务端发送数据了，可TCP连接是双向的，此时服务端还是可以给客户发送数据的)
- 如果有数据没传完，服务端继续把数据传完到客户端
- 客户端接收到最后一次数据后，向服务端发起确认断开请求，2ms后如果没有得到应答就自动断开请求

5. 也许会有疑问，此处为何一定要进行3次握手，明明两次就可已完成？
第三步确认连接是不能少的。假设客户端向服务端发送了请求A，当网络超时，导致A请求没能到达服务端，此时的客户端就会以为A失效了，会重新发送一个请求B，可TCP有一个超时重传的机制，还会保证数据包不会丢失，会将A请求重新发往服务端，可没有超时的请求B会先到达服务端，服务端对B作出响应，这便只有两次握手，建立连接，数据传输完毕后连接断开，可之后TCP重传的那个超时的请求A才来到服务端，服务端会认为是客户端又要开始建立连接了，于是给予响应，可此时的客户端已关闭，服务端会一直等待，造成资源浪费。

6. 客户端接收到数据后，会该数据进行词法解析，分析为一段一段的字符串，并打上标记，标记出那些div、p、a、i等标签，以这些标签作为node节点，根据这些节点之间的联系构建出DOM树，以此也对CSS文件进行分析，对应的类名、标签名作为节点，更具这些节点的联系，构建出CSSDOM树，对CSSDOM树进行递归确定具体的元素到底是什么样式，DOM树和CSSDOM树即构成了渲染树，GPU进程根据该渲染树绘制页面布局



